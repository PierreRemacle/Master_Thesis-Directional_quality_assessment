from sklearn.manifold import trustworthiness
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import MDS
from mpl_toolkits.mplot3d import Axes3D

"""CCA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N4uWYdOiUqBzi-uTQx_Xraz_2N7OkAN4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


from scipy.spatial.distance import cdist
from sklearn.metrics import pairwise_distances as pdist
from sklearn.decomposition import PCA


class CCA:
    def __init__(self, p, lmbd, alpha):
        """
        Creates the CCA object.

        Parameters
        ----------
        p : int
            The new dimension.
        lmbd : float
            Distance limit to update points. It decreases over time : lambda(t) = lambda/(t+1).
        alpha : float
            Learning rate. It decreases over time : alpha(t) = alpha/(t+1)
        """
        self.p = p
        self.lmbd = lmbd
        self.alpha = alpha

    def _stress(self, dist_y, dist_x, lmbda):
        """
        Calculates the stress function given the distances in original space (dist_y)
        and the distances in reduced space (dist_x).

        Parameters
        ----------
        dist_y : numpy.array
            Array with distances in original space.
        dist_x : numpy.array
            Array with distances in reduced space.
        lmbda : float
            Distance limit to update points.
        """
        stress = np.mean((dist_y - dist_x)**2 * (lmbda > dist_x).astype(int))
        return stress

    def run(self, data_y, q_max=10, show=False, tol=1e-4):
        """
        Method to reduce dimension. Every iteration run all points. The new data
        is stored in attribute 'data_x'.

        Parameters
        ----------
        data_y : numpy.array
            Array with the original data.
        q_max : int (default = 10)
            Number of iterations. Each iteration run all points in 'data_y'.
        show : boolean (default = False)
            If True, shows the stress curve along time.
        tol : float (default = 1e-4)
            Tolerance for the stopping criteria.

        Returns
        -------
        data_x : numpy.array
            New data representation.
        """
        self.data_y = data_y
        n = len(data_y)
        triu = np.triu_indices(n, 1)
        dist_y = pdist(data_y)
        data_x = PCA(self.p).fit_transform(data_y)
        stress = np.zeros(q_max)
        print("Progress: 0.0%", end='\r')
        for q in range(q_max):
            alpha = max(0.001, self.alpha/(1+q))
            lmbda = max(0.1, self.lmbd/(1+q))
            for i in range(n):
                dist_x = cdist(data_x[i].reshape(1, -1), data_x)
                dy = np.delete(dist_y[i], i, 0)
                dx = np.delete(dist_x, i, 1)
                delta_x = (alpha*(lmbda > dx)*(dy - dx)/dx).reshape((-1, 1)
                                                                    )*(data_x[i] - np.delete(data_x, i, 0))
                delta_x = np.insert(delta_x, i, 0, axis=0)
                data_x -= delta_x
            dist_x = pdist(data_x)
            stress[q] = self._stress(dist_y[triu], dist_x[triu], lmbda)
            if stress[q] < tol:
                print("Progress: 100.00%")
                print(f"Tol achieved in iteration {q}")
                break
            print(f"Progress: {round((q+1)*100/q_max, 2)}%  ", end='\r')
        if show:
            plt.plot(np.arange(q_max), stress, marker='.', c='black')
            plt.xlabel("Iteration")
            plt.ylabel("Stress")
            plt.show()
        print()
        self.data_x = data_x
        return data_x

    def plotYX(self):
        """
        Creates the dy dx Representation with the original and the reduced data.
        """
        reduced_data = self.data_x
        original_data = self.data_y
        dy = []
        dx = []

        for i in range(reduced_data.shape[0]):
            y1 = reduced_data[i, :]
            x1 = original_data[i, :]
            for j in range(i+1, reduced_data.shape[0]):
                y2 = reduced_data[j, :]
                x2 = original_data[j, :]
                dy.append(np.linalg.norm(y2-y1))
                dx.append(np.linalg.norm(x2-x1))
        plt.scatter(dy, dx, c='black', s=1)
        lims = [
            np.min([plt.xlim(), plt.ylim()]),  # min of both axes
            np.max([plt.xlim(), plt.ylim()]),  # max of both axes
        ]
        plt.plot(lims, lims, 'k-', alpha=0.75, zorder=0)
        plt.xlim(lims)
        plt.ylim(lims)
        plt.ylabel("Distance between points in original space")
        plt.xlabel("Distance between points in reduced space")
        plt.show()


# Generate random points on a 3D sphere
def generate_spherical_data(n_points=100, radius=1):
    phi = np.random.uniform(0, np.pi, n_points)
    theta = np.random.uniform(0, 2 * np.pi, n_points)
    x = radius * np.sin(phi) * np.cos(theta)
    y = radius * np.sin(phi) * np.sin(theta)
    z = radius * np.cos(phi)

    # select 7 random seeds for the colors
    seeds = np.random.choice(n_points, 7, replace=False)
    colors = np.zeros(n_points)
    for i in range(len(seeds)):
        colors[seeds[i]] = seeds[i]

    for point in range(n_points):
        if point not in seeds:
            distances_to_seeds = []
            for seed in seeds:
                distances_to_seeds.append(
                    np.linalg.norm([x[point] - x[seed], y[point] - y[seed], z[point] - z[seed]]))
            closest_seed = seeds[np.argmin(distances_to_seeds)]
            colors[point] = closest_seed
    # save to a file
    np.savetxt('spherical_data.csv', np.vstack((x, y, z)).T, delimiter=',')
    return np.vstack((x, y, z)).T, colors


# Generate the 3D spherical data
n_points = 1000
sphere_data, colors = generate_spherical_data(n_points=n_points)

# Perform PCA projection
pca = PCA(n_components=2)
PCA_X_transformed = pca.fit_transform(sphere_data)

# Perform CCA projection
cca = CCA(2, 10, 2)
CCA_X_transformed = cca.run(sphere_data, q_max=10)

# Function to compute trustworthiness and continuity over a range of K


def compute_metrics(data_3d, data_2d, max_neighbors=50):
    trust_scores = []
    continuity_scores = []
    for k in range(1, max_neighbors+1):
        trust = trustworthiness(data_3d, data_2d, n_neighbors=k)
        continuity = trustworthiness(data_2d, data_3d, n_neighbors=k)
        trust_scores.append(trust)
        continuity_scores.append(continuity)
    return trust_scores, continuity_scores


# Compute trustworthiness and continuity for PCA
pca_trust, pca_continuity = compute_metrics(sphere_data, PCA_X_transformed)

# Compute trustworthiness and continuity for CCA
cca_trust, cca_continuity = compute_metrics(sphere_data, CCA_X_transformed)

# Plot the trustworthiness and continuity evolution for PCA and CCA
fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for PCA: Trustworthiness and Continuity
axs[0, 0].plot(range(1, 51), pca_trust,
               label='PCA Trustworthiness', color='red')
axs[0, 0].plot(range(1, 51), pca_continuity,
               label='PCA Continuity', color='blue')
axs[0, 0].set_xlabel('Number of Neighbors (K)')
axs[0, 0].set_ylabel('Score')
axs[0, 0].set_title('PCA: Trustworthiness & Continuity')
axs[0, 0].legend()

# Plot for CCA: Trustworthiness and Continuity
axs[0, 1].plot(range(1, 51), cca_trust,
               label='CCA Trustworthiness', color='red')
axs[0, 1].plot(range(1, 51), cca_continuity,
               label='CCA Continuity', color='blue')
axs[0, 1].set_xlabel('Number of Neighbors (K)')
axs[0, 1].set_ylabel('Score')
axs[0, 1].set_title('CCA: Trustworthiness & Continuity')
axs[0, 1].legend()

# PCA 2D projection
colors_values = np.unique(colors)
colors_maps = ["red", "blue", "green", "yellow", "purple", "orange", "black"]
colors_output = [colors_maps[colors_values.tolist().index(c)] for c in colors]

axs[1, 0].scatter(PCA_X_transformed[:, 0], PCA_X_transformed[:, 1],
                  c=colors_output, cmap='rainbow', label='PCA')
axs[1, 0].set_title('PCA Projection')

# CCA 2D projection
axs[1, 1].scatter(CCA_X_transformed[:, 0], CCA_X_transformed[:, 1],
                  c=colors_output, cmap='rainbow', label='CCA')
axs[1, 1].set_title('CCA Projection')

plt.tight_layout()
# save the plot
plt.savefig('trustworthiness.png')
plt.show()
